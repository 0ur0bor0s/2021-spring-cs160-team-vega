'use strict';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      _defineProperty(target, key, source[key]);
    });
  }

  return target;
}

var GraphQLClient =
/*#__PURE__*/
function () {
  function GraphQLClient(config) {
    if (config === void 0) {
      config = {};
    }

    // validate config
    if (!config.url) {
      throw new Error('GraphQLClient: config.url is required');
    }

    if (config.fetch && typeof config.fetch !== 'function') {
      throw new Error('GraphQLClient: config.fetch must be a function');
    }

    if (!config.fetch && !fetch) {
      throw new Error('GraphQLClient: fetch must be polyfilled or passed in new GraphQLClient({ fetch })');
    }

    if (config.ssrMode && !config.cache) {
      throw new Error('GraphQLClient: config.cache is required when in ssrMode');
    }

    this.cache = config.cache;
    this.headers = config.headers || {};
    this.ssrMode = config.ssrMode;
    this.ssrPromises = [];
    this.url = config.url;
    this.fetch = config.fetch || fetch.bind();
    this.fetchOptions = config.fetchOptions || {};
    this.logErrors = config.logErrors !== undefined ? config.logErrors : true;
    this.onError = config.onError;
  }

  var _proto = GraphQLClient.prototype;

  _proto.setHeader = function setHeader(key, value) {
    this.headers[key] = value;
    return this;
  };

  _proto.setHeaders = function setHeaders(headers) {
    this.headers = headers;
    return this;
  }
  /* eslint-disable no-console */
  ;

  _proto.logErrorResult = function logErrorResult(_ref) {
    var result = _ref.result,
        operation = _ref.operation;

    if (this.onError) {
      return this.onError({
        result: result,
        operation: operation
      });
    }

    console.error('GraphQL Hooks Error');
    console.groupCollapsed('---> Full Error Details');
    console.groupCollapsed('Operation:');
    console.log(operation);
    console.groupEnd();

    if (result.fetchError) {
      console.groupCollapsed('FETCH ERROR:');
      console.log(result.fetchError);
      console.groupEnd();
    }

    if (result.httpError) {
      console.groupCollapsed('HTTP ERROR:');
      console.log(result.httpError);
      console.groupEnd();
    }

    if (result.graphQLErrors && result.graphQLErrors.length > 0) {
      console.groupCollapsed('GRAPHQL ERROR:');
      result.graphQLErrors.forEach(function (err) {
        return console.log(err);
      });
      console.groupEnd();
    }

    console.groupEnd();
  }
  /* eslint-enable no-console */
  ;

  _proto.generateResult = function generateResult(_ref2) {
    var fetchError = _ref2.fetchError,
        httpError = _ref2.httpError,
        graphQLErrors = _ref2.graphQLErrors,
        data = _ref2.data;
    var error = !!(graphQLErrors && graphQLErrors.length > 0 || fetchError || httpError);
    return {
      error: error,
      fetchError: fetchError,
      httpError: httpError,
      graphQLErrors: graphQLErrors,
      data: data
    };
  };

  _proto.getCacheKey = function getCacheKey(operation, options) {
    if (options === void 0) {
      options = {};
    }

    var fetchOptions = _objectSpread({}, this.fetchOptions, options.fetchOptionsOverrides);

    return {
      operation: operation,
      fetchOptions: fetchOptions
    };
  };

  _proto.request = function request(operation, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    return this.fetch(this.url, _objectSpread({
      method: 'POST',
      headers: _objectSpread({
        'Content-Type': 'application/json'
      }, this.headers),
      body: JSON.stringify({
        query: operation.query,
        variables: operation.variables,
        operationName: operation.operationName
      })
    }, this.fetchOptions, options.fetchOptionsOverrides)).then(function (response) {
      if (!response.ok) {
        return response.text().then(function (body) {
          var status = response.status,
              statusText = response.statusText;
          return _this.generateResult({
            httpError: {
              status: status,
              statusText: statusText,
              body: body
            }
          });
        });
      } else {
        return response.json().then(function (_ref3) {
          var errors = _ref3.errors,
              data = _ref3.data;
          return _this.generateResult({
            graphQLErrors: errors,
            data: data
          });
        });
      }
    }).catch(function (error) {
      return _this.generateResult({
        fetchError: error
      });
    }).then(function (result) {
      if (result.error && _this.logErrors) {
        _this.logErrorResult({
          result: result,
          operation: operation
        });
      }

      return result;
    });
  };

  return GraphQLClient;
}();

exports.GraphQLClient = GraphQLClient;
exports._objectSpread = _objectSpread;
